---
output: 
  html_document: 
    keep_md: yes
---

Package `regez` is mostly an exercise to demonstrate the use of package [`Function`](https://github.com/piccolbo/Function). The goal  of `regez` is to support writing of readable and maintainable regular expressions, but also to demonstrate the advantages of developing using `Function`. A more mature alternative for the first task is package [`rex`](https://github.com/kevinushey/rex). In particular, `rex` has a serious set of tests, whereas work on that has just started in `regez`. The main advantage of `regez` over `rex` is that `regez` checks every regular expression that it generates before use. Therefore, when assembling a complex expression from its parts, `regez` will fail early and point to the reason of a failure. With `rex`, you'll find out only when using the fully assembled regex, and it's up to you to break it down and fix it.

For instance
```{r, error=TRUE}
library(rex)
rex(regex("abc["), "def")
grep(rex(regex("abc["), "def"), "")
```

Friendly, maybe, but friends don't let friends write incorrect regular expressions. With `regez`:

```{r}
detach()
library(regez)
regex(~"abc[" %+% "def")
```

Yep, I can't even write an incorrect regex in `regez`. Well, at least, that's the goal, but if you do, it should be detected immediately. Let me try harder

```{r, error=TRUE}
regex(~named.capture(at.least.one(anychar), "copy") %+% named.ref("cop"))
regex(~named.capture(at.least.one(anychar), "copy") %+% named.ref("copy"))
```

QED.

To approximately reproduce the (brilliant) `rex` example here, guess what this does:

```
"^(?:((?:[^:])+)://)?((?:!(?::/))+)(?:(:(?:\\d)+))?(?:(/(?:.)*))?$"
```

And now guess what this does:

```{r}
regex(~{
  protocol = at.least.one(none.of(":"))
  domain = at.least.one(not(":/"))
  port =  at.least.one(digit)
  path = anything
  line.begin %+%
    optional(capture(protocol) %+% "://") %+%
    capture(domain) %+%
    optional(":" %+% capture(port)) %+%
    optional("/" %+% capture(path)) %+%
    line.end})
```

It is a very liberal regex for URLs and I don't recommend using it in practice. But a  more accurate one is only going to be more complex and is going to benefit even more from using `regez`.

Taking a page from `rex`, `regez` exposes a single function in its API. This is to avoid polluting the search space while using the shortest names possibles for regex concepts. This is also because one doesn't normally scatter the building of a regex all over one's code as one would do with a more general purpose library. Therefore, all the other `regez` functions are accessbile only in a special evaluation environment created by `regex`, which takes a formula as an argument (to defer evaluation to the function itself). Therefore all regex are generated by expressions like `regez(~ ...)`. All the regex-building functions and constants are available in an environment, `regez.env`. If you are not worried about polluting the search path and want to use completion and what not, you can just `attach(regez.env)` and `detach` it later:


```{r}
attach(regez.env)
protocol = at.least.one(none.of(":"))
domain = at.least.one(not(":/"))
port =  at.least.one(digit)
path = anything
line.begin %+%
optional(capture(protocol) %+% "://") %+%
capture(domain) %+%
optional(":" %+% capture(port)) %+%
optional("/" %+% capture(path)) %+%
line.end
detach()
```

Using this approach has a couple of drawbacks: 

- a `regex` thus created can not be used in `grep` directly without producing  a warning. Wrap it in a `regex` call before passing to, say, `grep` to prevent that, that is, get a regular character string out of a `RegEx` object.
- checking that all backrefs are resolved is disabled; again `regex` does that.