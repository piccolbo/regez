
Package `regez` is mostly an exercise to demonstrate the use of package [`Function`](https://github.com/piccolbo/Function). The goal  of `regez` is to support writing of readable and maintainable regular expressions. A more mature alternative is package [`rex`](https://github.com/kevinushey/rex). In particular, `rex` has a serious set of tests, whereas work on that has just started in `regez`. The main advantage of `regez` over `rex` is that `regez` checks every regular expression that it generates before use. Therefore, when assembling a complex expression from its parts, `regez` will fail early and point to the reason of a failure. With `rex`, you'll find out only when using the fully assembled regex, and it's up to you to break it down and fix it.

For instance

```r
library(rex)
```

```
## Welcome to rex, the friendly regular expression helper!
## Use 'rex_mode()' to toggle code completion for rex shortcuts and functions.
```

```r
rex(regex("abc["), "def")
```

```
## abc[def
```

```r
grep(rex(regex("abc["), "def"), "")
```

```
## Error in grep(rex(regex("abc["), "def"), ""): invalid regular expression 'abc[def', reason 'Missing ']''
```

Friendly, maybe, but friends don't let friends write incorrect regular expressions. With `regez`:


```r
detach()
library(regez)
regex(~"abc[" %+% "def")
```

```
## [1] "abc\\[def"
```

Yep, I can't even write an incorrect regex in `regez`. Well, at least, that's the goal, but if you do, it should be detected immediately. Let me try harder


```r
regex(~named.capture(at.least.one(anychar), "copy") %+% named.ref("cop"))
```

```
## Error in (function (rx_) : Unresolved backrefs: cop
```

```r
regex(~named.capture(at.least.one(anychar), "copy") %+% named.ref("copy"))
```

```
## [1] "(?<copy>(?:.)+)\\g{copy}"
```

QED.

To approximately reproduce the (brilliant, but not standards compliant) `rex` example here, guess what this does:

```
"^(?:((?:[^:])+)://)?((?:!(?::/))+)(?:(:(?:\\d)+))?(?:(/(?:.)*))?$"
```

And now guess what this does:


```r
regex(~{
  protocol = at.least.one(none.of(":"))
  domain = at.least.one(not(":/"))
  port =  at.least.one(digit)
  path = anything
  line.begin %+%
    optional(capture(protocol) %+% "://") %+%
    capture(domain) %+%
    optional(":" %+% capture(port)) %+%
    optional("/" %+% capture(path)) %+%
    line.end})
```

```
## [1] "^(?:((?:[^:])+)://)?((?:(?!(?:.)*:/)(?:.)*)+)(?::((?:\\d)+))?(?:/((?:.)*))?$"
```

It is a very liberal regex for URLs and I don't recommend using it in practice. But a  more accurate one is only going to be more complex and is going to benefit even more from using `regez`.

Taking a page from `rex`, `regez` exposes a single function in its API. This is to avoid polluting the search space while using the shortest names possibles for regex concepts. This is also because one doesn't normally scatter the building of a regex all over one's code as one would do with a more general purpose library. Therefore, all the other `regez` functions are accessbile only in a special evaluation environment created by `regex`, which takes a formula as an argument (to defer evaluation to the function itself). Therefore all regex are generated by expressions like `regez(~ ...)`. As a consequence, even accessing the documentation requires `regex`: `regex(~help(any.of))`. All the regex-building functions and constants are available in an environment, `regez.env`. If you are not worried about polluting the search path and want to use completion and what not, you can just `attach(regez.env)` and `detach` it later:



```r
attach(regez.env)
protocol = at.least.one(none.of(":"))
domain = at.least.one(not(":/"))
port =  at.least.one(digit)
path = anything
line.begin %+%
  optional(capture(protocol) %+% "://") %+%
  capture(domain) %+%
  optional(":" %+% capture(port)) %+%
  optional("/" %+% capture(path)) %+%
  line.end
```

```
## ^(?:((?:[^:])+)://)?((?:(?!(?:.)*:/)(?:.)*)+)(?::((?:\d)+))?(?:/((?:.)*))?$
```

```r
detach()
```

Using this approach has a couple of drawbacks
